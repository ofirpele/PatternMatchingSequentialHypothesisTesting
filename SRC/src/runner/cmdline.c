/*
  File autogenerated by gengetopt version 2.19.1
  generated with the following command:
  gengetopt -ihm.ggo -Fcmdline --unamed-opts 

  The developers of gengetopt consider the fixed text that goes in all
  gengetopt output files to be in the public domain:
  we make no copyright claims on it.
*/

/* If we use autoconf.  */
#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "getopt.h"

#include "cmdline.h"

const char *gengetopt_args_info_purpose = "This program detects patterns in images.";

const char *gengetopt_args_info_usage = "Usage: hs [OPTIONS]... [FILES]...";

const char *gengetopt_args_info_description = "";

const char *gengetopt_args_info_help[] = {
  "  -h, --help                    Print help and exit",
  "      --full-help               Print help, including hidden options, and exit",
  "  -V, --version                 Print version and exit",
  "\nImages & masks images file names:",
  "  -P, --pattern=file_name       The file name of the pattern image.",
  "  -M, --mask=file_name          The file name of the pattern mask image \n                                  (0<->not in mask, other values<->in mask). If \n                                  not given all pixels are considered.",
  "  -I, --images=file_name/dir_name\n                                The file name of the image, or, (if ends with \n                                  '/') the name of the directory containing the \n                                  images.",
  "\nOutput:",
  "      --print-found-windows     The program will print to the standard output \n                                  the top left of the masked windows where the \n                                  pattern was found and the distance of each \n                                  masked window to the pattern. The format of \n                                  the output is: y x distance. x and y starts \n                                  from 0.  (default=off)",
  "      --no-show                 The program will not show the places where the \n                                  pattern was found.  (default=off)",
  "\nDistance & matching strategy:",
  "  -D, --dist=type               Type of distance (possible values: \n                                  abs,gt-pairs). abs: ''Thresholded Absolute \n                                  Difference'' from the paper. gt-pairs: \n                                  ''Monotonic Relations'' from the paper.  \n                                  (default=`gt-pairs')",
  "  -T, --thresh=num              Threshold for distance. 0 <= thresh <=50. \n                                  Defaults: gt-pairs = 0, abs = 20.",
  "      --outliers=percent        Maximum percent of outliers allowed. i.e: \n                                  Similar windows are if the Hamming distance \n                                  is smaller or equal to \n                                  (outliers/100)*num_of_features. Defaults: \n                                  gt-pairs = 25, abs = 40.",
  "      --match=type              Matching algorithm (possible values: exact, \n                                  seq). seq is the P-SPRT sequential procedure \n                                  from the paper.  (default=`seq')",
  "      --fn=percent              Bound on false negative error rate, only needed \n                                  when matching is with sampling (match=seq).  \n                                  (default=`0.1')",
  "\ngt-pairs mask options:",
  "  These options require that --dist=gt-pairs. The options determine which pairs \n  of pixels will be in the mask. Note that all pixels must also be in the given \n  mask (--mask).",
  "      --gt-neighbor=num         A pixel (x',y') is greater than it's neighbor \n                                  (x,y) when: g(x,y) > g(x',y')+gt-neighbor. \n                                  thresh should be <= than gt-neighbor.  \n                                  (default=`80')",
  "      --max-neighbor=num        Maximum distance of a neighbor. i.e: (x,y) is a \n                                  neighbor of (x',y') when the Euclidean \n                                  distance between them is less than or equal \n                                  to max-neighbor-val.  (default=`3')",
  "      --min-neighbor=num        Minimum distance of a neighbor. i.e: (x,y) is a \n                                  neighbor of (x',y') if if the Euclidean \n                                  distance between them is greater than or \n                                  equal to max-neighbor-val.  (default=`1')",
  "\nOthers:",
  "      --find=type               Type of find (possible values: min, \n                                  lessOutliers). min: finds only the windows \n                                  with the minimum distance. lessOutliers: \n                                  finds all windows that have a distance which \n                                  is smaller or equal to \n                                  (outliers/100)*num_of_features  \n                                  (default=`lessOutliers')",
  "      --save=directory          If given results will be saved in the given \n                                  directory.",
  "      --run-time=iterations     Number of iterations that the program will do \n                                  in order to measure running time. Note that \n                                  if it's <=0 no run time information will be \n                                  displayed.  (default=`0')",
  "      --run-time-file-name=file_name\n                                The file name that the run time (in seconds) \n                                  will be written to. If not given it's written \n                                  only to stdout.",
  "\nLU jumps:",
  "  LU jumps for acceleration (see ACCV 2007 paper). Only for --match=seq",
  "      --LU-off                  The program will not use the LU jump technique \n                                  (will be more accurate but slower).  \n                                  (default=off)",
  "      --LU-min-num-of-LU-pixels=num\n                                Minimum number of LU pixels in the LU mask  \n                                  (default=`30')",
  "      --LU-gt-neighbor=num      Same as gt-neighbor for finding LU rank of \n                                  pairs. default: abs=5 gt-pairs=20",
  "      --LU-fn=percent           same as --fn for LU stage  (default=`0.1')",
  "      --LU-outliers=percent     same as --outliers for LU stage. Default: \n                                  equals to outliers",
    0
};
const char *gengetopt_args_info_full_help[] = {
  "  -h, --help                    Print help and exit",
  "      --full-help               Print help, including hidden options, and exit",
  "  -V, --version                 Print version and exit",
  "\nImages & masks images file names:",
  "  -P, --pattern=file_name       The file name of the pattern image.",
  "  -M, --mask=file_name          The file name of the pattern mask image \n                                  (0<->not in mask, other values<->in mask). If \n                                  not given all pixels are considered.",
  "  -I, --images=file_name/dir_name\n                                The file name of the image, or, (if ends with \n                                  '/') the name of the directory containing the \n                                  images.",
  "\nOutput:",
  "      --print-found-windows     The program will print to the standard output \n                                  the top left of the masked windows where the \n                                  pattern was found and the distance of each \n                                  masked window to the pattern. The format of \n                                  the output is: y x distance. x and y starts \n                                  from 0.  (default=off)",
  "      --no-show                 The program will not show the places where the \n                                  pattern was found.  (default=off)",
  "\nDistance & matching strategy:",
  "  -D, --dist=type               Type of distance (possible values: \n                                  abs,gt-pairs). abs: ''Thresholded Absolute \n                                  Difference'' from the paper. gt-pairs: \n                                  ''Monotonic Relations'' from the paper.  \n                                  (default=`gt-pairs')",
  "  -T, --thresh=num              Threshold for distance. 0 <= thresh <=50. \n                                  Defaults: gt-pairs = 0, abs = 20.",
  "      --outliers=percent        Maximum percent of outliers allowed. i.e: \n                                  Similar windows are if the Hamming distance \n                                  is smaller or equal to \n                                  (outliers/100)*num_of_features. Defaults: \n                                  gt-pairs = 25, abs = 40.",
  "      --match=type              Matching algorithm (possible values: exact, \n                                  seq). seq is the P-SPRT sequential procedure \n                                  from the paper.  (default=`seq')",
  "      --fn=percent              Bound on false negative error rate, only needed \n                                  when matching is with sampling (match=seq).  \n                                  (default=`0.1')",
  "\ngt-pairs mask options:",
  "  These options require that --dist=gt-pairs. The options determine which pairs \n  of pixels will be in the mask. Note that all pixels must also be in the given \n  mask (--mask).",
  "      --gt-neighbor=num         A pixel (x',y') is greater than it's neighbor \n                                  (x,y) when: g(x,y) > g(x',y')+gt-neighbor. \n                                  thresh should be <= than gt-neighbor.  \n                                  (default=`80')",
  "      --max-neighbor=num        Maximum distance of a neighbor. i.e: (x,y) is a \n                                  neighbor of (x',y') when the Euclidean \n                                  distance between them is less than or equal \n                                  to max-neighbor-val.  (default=`3')",
  "      --min-neighbor=num        Minimum distance of a neighbor. i.e: (x,y) is a \n                                  neighbor of (x',y') if if the Euclidean \n                                  distance between them is greater than or \n                                  equal to max-neighbor-val.  (default=`1')",
  "      --window-size=num         The pattern is divided into windows of \n                                  window-size.  (default=`1')",
  "      --max-from-window=num     From each window a maximum of max-from-window \n                                  pixels pairs is taken. If not given it's the \n                                  maximum number of pixels pairs possible.",
  "\nOthers:",
  "      --find=type               Type of find (possible values: min, \n                                  lessOutliers). min: finds only the windows \n                                  with the minimum distance. lessOutliers: \n                                  finds all windows that have a distance which \n                                  is smaller or equal to \n                                  (outliers/100)*num_of_features  \n                                  (default=`lessOutliers')",
  "      --show-dilate-border=num  The size of dilation of the border of the mask \n                                  that will be shown will be 2*val-1. Should be \n                                  => 1  (default=`2')",
  "      --save=directory          If given results will be saved in the given \n                                  directory.",
  "      --run-time=iterations     Number of iterations that the program will do \n                                  in order to measure running time. Note that \n                                  if it's <=0 no run time information will be \n                                  displayed.  (default=`0')",
  "      --run-time-file-name=file_name\n                                The file name that the run time (in seconds) \n                                  will be written to. If not given it's written \n                                  only to stdout.",
  "      --statistics=iterations   Number of iterations that the program will do \n                                  in order to check the statistics - average \n                                  false negative and average iterations. Note \n                                  that if it's <=0 no statistics will be \n                                  displayed. Should not be given with exact.  \n                                  (default=`0')",
  "      --false-negative-filename=file_name\n                                The file name that the false negative error \n                                  rate (windows that are similar i.e: are \n                                  smaller than the (outliers/100)*pattern_size, \n                                  that were classified as not similar) will be \n                                  written to. If not given it's written only to \n                                  stdout.",
  "      --iterations-filename=file_name\n                                The file name that the average iterations per \n                                  window will be written to. If not given it's \n                                  written only to stdout.",
  "      --expected-detections-image=file_name\n                                The file name of the expected detections image. \n                                  Same size as the given image (-I option). The \n                                  values in this map are: EXPECTED_DETECT= 255; \n                                  NOT_EXPECTED_DETECT= 0; \n                                  DOES_NOT_MATTER_EXPECTED_DETECT= 100",
  "      --detections-it=iterations\n                                Number of iterations that the program will do \n                                  in order to measure detection and running \n                                  time. Note that if it's <=0 no detections and \n                                  false detections information will be \n                                  displayed.  (default=`0')",
  "      --detections-rate-filename=file_name\n                                The file name that the average detection rate \n                                  (percent of images that at least one of the \n                                  expected was found, out of all iterations on \n                                  images that contains expected) will be \n                                  written to. If not given it's written only to \n                                  stdout.",
  "      --false-detections-rate-filename=file_name\n                                The file name that the average false detection \n                                  rate (percent of images that at least one of \n                                  the not expected was found, out of all \n                                  iterations on images that contains not \n                                  expected) will be written to. If not given \n                                  it's written only to stdout.",
  "      --false-detections-rate-in-image-filename=file_name\n                                The file name that the average false detection \n                                  rate (percent of places that were found and \n                                  were not expect to be found, out of all not \n                                  expected places) will be written to. If not \n                                  given it's written only to stdout.",
  "\nLU jumps:",
  "  LU jumps for acceleration (see ACCV 2007 paper). Only for --match=seq",
  "      --LU-off                  The program will not use the LU jump technique \n                                  (will be more accurate but slower).  \n                                  (default=off)",
  "      --LU-min-num-of-LU-pixels=num\n                                Minimum number of LU pixels in the LU mask  \n                                  (default=`30')",
  "      --LU-gt-neighbor=num      Same as gt-neighbor for finding LU rank of \n                                  pairs. default: abs=5 gt-pairs=20",
  "      --LU-fn=percent           same as --fn for LU stage  (default=`0.1')",
  "      --LU-outliers=percent     same as --outliers for LU stage. Default: \n                                  equals to outliers",
    0
};

static
void clear_given (struct gengetopt_args_info *args_info);
static
void clear_args (struct gengetopt_args_info *args_info);

static int
cmdline_parser_internal (int argc, char * const *argv, struct gengetopt_args_info *args_info, int override, int initialize, int check_required, const char *additional_error);

static int
cmdline_parser_required2 (struct gengetopt_args_info *args_info, const char *prog_name, const char *additional_error);

static char *
gengetopt_strdup (const char *s);

static
void clear_given (struct gengetopt_args_info *args_info)
{
  args_info->help_given = 0 ;
  args_info->full_help_given = 0 ;
  args_info->version_given = 0 ;
  args_info->pattern_given = 0 ;
  args_info->mask_given = 0 ;
  args_info->images_given = 0 ;
  args_info->print_found_windows_given = 0 ;
  args_info->no_show_given = 0 ;
  args_info->dist_given = 0 ;
  args_info->thresh_given = 0 ;
  args_info->outliers_given = 0 ;
  args_info->match_given = 0 ;
  args_info->fn_given = 0 ;
  args_info->gt_neighbor_given = 0 ;
  args_info->max_neighbor_given = 0 ;
  args_info->min_neighbor_given = 0 ;
  args_info->window_size_given = 0 ;
  args_info->max_from_window_given = 0 ;
  args_info->find_given = 0 ;
  args_info->show_dilate_border_given = 0 ;
  args_info->save_given = 0 ;
  args_info->run_time_given = 0 ;
  args_info->run_time_file_name_given = 0 ;
  args_info->statistics_given = 0 ;
  args_info->false_negative_filename_given = 0 ;
  args_info->iterations_filename_given = 0 ;
  args_info->expected_detections_image_given = 0 ;
  args_info->detections_it_given = 0 ;
  args_info->detections_rate_filename_given = 0 ;
  args_info->false_detections_rate_filename_given = 0 ;
  args_info->false_detections_rate_in_image_filename_given = 0 ;
  args_info->LU_off_given = 0 ;
  args_info->LU_min_num_of_LU_pixels_given = 0 ;
  args_info->LU_gt_neighbor_given = 0 ;
  args_info->LU_fn_given = 0 ;
  args_info->LU_outliers_given = 0 ;
}

static
void clear_args (struct gengetopt_args_info *args_info)
{
  args_info->pattern_arg = NULL;
  args_info->pattern_orig = NULL;
  args_info->mask_arg = NULL;
  args_info->mask_orig = NULL;
  args_info->images_arg = NULL;
  args_info->images_orig = NULL;
  args_info->print_found_windows_flag = 0;
  args_info->no_show_flag = 0;
  args_info->dist_arg = gengetopt_strdup ("gt-pairs");
  args_info->dist_orig = NULL;
  args_info->thresh_orig = NULL;
  args_info->outliers_orig = NULL;
  args_info->match_arg = gengetopt_strdup ("seq");
  args_info->match_orig = NULL;
  args_info->fn_arg = 0.1;
  args_info->fn_orig = NULL;
  args_info->gt_neighbor_arg = 80;
  args_info->gt_neighbor_orig = NULL;
  args_info->max_neighbor_arg = 3;
  args_info->max_neighbor_orig = NULL;
  args_info->min_neighbor_arg = 1;
  args_info->min_neighbor_orig = NULL;
  args_info->window_size_arg = 1;
  args_info->window_size_orig = NULL;
  args_info->max_from_window_orig = NULL;
  args_info->find_arg = gengetopt_strdup ("lessOutliers");
  args_info->find_orig = NULL;
  args_info->show_dilate_border_arg = 2;
  args_info->show_dilate_border_orig = NULL;
  args_info->save_arg = NULL;
  args_info->save_orig = NULL;
  args_info->run_time_arg = 0;
  args_info->run_time_orig = NULL;
  args_info->run_time_file_name_arg = NULL;
  args_info->run_time_file_name_orig = NULL;
  args_info->statistics_arg = 0;
  args_info->statistics_orig = NULL;
  args_info->false_negative_filename_arg = NULL;
  args_info->false_negative_filename_orig = NULL;
  args_info->iterations_filename_arg = NULL;
  args_info->iterations_filename_orig = NULL;
  args_info->expected_detections_image_arg = NULL;
  args_info->expected_detections_image_orig = NULL;
  args_info->detections_it_arg = 0;
  args_info->detections_it_orig = NULL;
  args_info->detections_rate_filename_arg = NULL;
  args_info->detections_rate_filename_orig = NULL;
  args_info->false_detections_rate_filename_arg = NULL;
  args_info->false_detections_rate_filename_orig = NULL;
  args_info->false_detections_rate_in_image_filename_arg = NULL;
  args_info->false_detections_rate_in_image_filename_orig = NULL;
  args_info->LU_off_flag = 0;
  args_info->LU_min_num_of_LU_pixels_arg = 30;
  args_info->LU_min_num_of_LU_pixels_orig = NULL;
  args_info->LU_gt_neighbor_orig = NULL;
  args_info->LU_fn_arg = 0.1;
  args_info->LU_fn_orig = NULL;
  args_info->LU_outliers_orig = NULL;
  
}

static
void init_args_info(struct gengetopt_args_info *args_info)
{
  args_info->help_help = gengetopt_args_info_full_help[0] ;
  args_info->full_help_help = gengetopt_args_info_full_help[1] ;
  args_info->version_help = gengetopt_args_info_full_help[2] ;
  args_info->pattern_help = gengetopt_args_info_full_help[4] ;
  args_info->mask_help = gengetopt_args_info_full_help[5] ;
  args_info->images_help = gengetopt_args_info_full_help[6] ;
  args_info->print_found_windows_help = gengetopt_args_info_full_help[8] ;
  args_info->no_show_help = gengetopt_args_info_full_help[9] ;
  args_info->dist_help = gengetopt_args_info_full_help[11] ;
  args_info->thresh_help = gengetopt_args_info_full_help[12] ;
  args_info->outliers_help = gengetopt_args_info_full_help[13] ;
  args_info->match_help = gengetopt_args_info_full_help[14] ;
  args_info->fn_help = gengetopt_args_info_full_help[15] ;
  args_info->gt_neighbor_help = gengetopt_args_info_full_help[18] ;
  args_info->max_neighbor_help = gengetopt_args_info_full_help[19] ;
  args_info->min_neighbor_help = gengetopt_args_info_full_help[20] ;
  args_info->window_size_help = gengetopt_args_info_full_help[21] ;
  args_info->max_from_window_help = gengetopt_args_info_full_help[22] ;
  args_info->find_help = gengetopt_args_info_full_help[24] ;
  args_info->show_dilate_border_help = gengetopt_args_info_full_help[25] ;
  args_info->save_help = gengetopt_args_info_full_help[26] ;
  args_info->run_time_help = gengetopt_args_info_full_help[27] ;
  args_info->run_time_file_name_help = gengetopt_args_info_full_help[28] ;
  args_info->statistics_help = gengetopt_args_info_full_help[29] ;
  args_info->false_negative_filename_help = gengetopt_args_info_full_help[30] ;
  args_info->iterations_filename_help = gengetopt_args_info_full_help[31] ;
  args_info->expected_detections_image_help = gengetopt_args_info_full_help[32] ;
  args_info->detections_it_help = gengetopt_args_info_full_help[33] ;
  args_info->detections_rate_filename_help = gengetopt_args_info_full_help[34] ;
  args_info->false_detections_rate_filename_help = gengetopt_args_info_full_help[35] ;
  args_info->false_detections_rate_in_image_filename_help = gengetopt_args_info_full_help[36] ;
  args_info->LU_off_help = gengetopt_args_info_full_help[39] ;
  args_info->LU_min_num_of_LU_pixels_help = gengetopt_args_info_full_help[40] ;
  args_info->LU_gt_neighbor_help = gengetopt_args_info_full_help[41] ;
  args_info->LU_fn_help = gengetopt_args_info_full_help[42] ;
  args_info->LU_outliers_help = gengetopt_args_info_full_help[43] ;
  
}

void
cmdline_parser_print_version (void)
{
  printf ("%s %s\n", CMDLINE_PARSER_PACKAGE, CMDLINE_PARSER_VERSION);
}

void
cmdline_parser_print_help (void)
{
  int i = 0;
  cmdline_parser_print_version ();

  if (strlen(gengetopt_args_info_purpose) > 0)
    printf("\n%s\n", gengetopt_args_info_purpose);

  printf("\n%s\n\n", gengetopt_args_info_usage);

  if (strlen(gengetopt_args_info_description) > 0)
    printf("%s\n", gengetopt_args_info_description);

  while (gengetopt_args_info_help[i])
    printf("%s\n", gengetopt_args_info_help[i++]);
}

void
cmdline_parser_print_full_help (void)
{
  int i = 0;
  cmdline_parser_print_version ();

  if (strlen(gengetopt_args_info_purpose) > 0)
    printf("\n%s\n", gengetopt_args_info_purpose);

  printf("\n%s\n\n", gengetopt_args_info_usage);

  if (strlen(gengetopt_args_info_description) > 0)
    printf("%s\n", gengetopt_args_info_description);

  while (gengetopt_args_info_full_help[i])
    printf("%s\n", gengetopt_args_info_full_help[i++]);
}

void
cmdline_parser_init (struct gengetopt_args_info *args_info)
{
  clear_given (args_info);
  clear_args (args_info);
  init_args_info (args_info);

  args_info->inputs = NULL;
  args_info->inputs_num = 0;
}

static void
cmdline_parser_release (struct gengetopt_args_info *args_info)
{
  
  unsigned int i;
  if (args_info->pattern_arg)
    {
      free (args_info->pattern_arg); /* free previous argument */
      args_info->pattern_arg = 0;
    }
  if (args_info->pattern_orig)
    {
      free (args_info->pattern_orig); /* free previous argument */
      args_info->pattern_orig = 0;
    }
  if (args_info->mask_arg)
    {
      free (args_info->mask_arg); /* free previous argument */
      args_info->mask_arg = 0;
    }
  if (args_info->mask_orig)
    {
      free (args_info->mask_orig); /* free previous argument */
      args_info->mask_orig = 0;
    }
  if (args_info->images_arg)
    {
      free (args_info->images_arg); /* free previous argument */
      args_info->images_arg = 0;
    }
  if (args_info->images_orig)
    {
      free (args_info->images_orig); /* free previous argument */
      args_info->images_orig = 0;
    }
  if (args_info->dist_arg)
    {
      free (args_info->dist_arg); /* free previous argument */
      args_info->dist_arg = 0;
    }
  if (args_info->dist_orig)
    {
      free (args_info->dist_orig); /* free previous argument */
      args_info->dist_orig = 0;
    }
  if (args_info->thresh_orig)
    {
      free (args_info->thresh_orig); /* free previous argument */
      args_info->thresh_orig = 0;
    }
  if (args_info->outliers_orig)
    {
      free (args_info->outliers_orig); /* free previous argument */
      args_info->outliers_orig = 0;
    }
  if (args_info->match_arg)
    {
      free (args_info->match_arg); /* free previous argument */
      args_info->match_arg = 0;
    }
  if (args_info->match_orig)
    {
      free (args_info->match_orig); /* free previous argument */
      args_info->match_orig = 0;
    }
  if (args_info->fn_orig)
    {
      free (args_info->fn_orig); /* free previous argument */
      args_info->fn_orig = 0;
    }
  if (args_info->gt_neighbor_orig)
    {
      free (args_info->gt_neighbor_orig); /* free previous argument */
      args_info->gt_neighbor_orig = 0;
    }
  if (args_info->max_neighbor_orig)
    {
      free (args_info->max_neighbor_orig); /* free previous argument */
      args_info->max_neighbor_orig = 0;
    }
  if (args_info->min_neighbor_orig)
    {
      free (args_info->min_neighbor_orig); /* free previous argument */
      args_info->min_neighbor_orig = 0;
    }
  if (args_info->window_size_orig)
    {
      free (args_info->window_size_orig); /* free previous argument */
      args_info->window_size_orig = 0;
    }
  if (args_info->max_from_window_orig)
    {
      free (args_info->max_from_window_orig); /* free previous argument */
      args_info->max_from_window_orig = 0;
    }
  if (args_info->find_arg)
    {
      free (args_info->find_arg); /* free previous argument */
      args_info->find_arg = 0;
    }
  if (args_info->find_orig)
    {
      free (args_info->find_orig); /* free previous argument */
      args_info->find_orig = 0;
    }
  if (args_info->show_dilate_border_orig)
    {
      free (args_info->show_dilate_border_orig); /* free previous argument */
      args_info->show_dilate_border_orig = 0;
    }
  if (args_info->save_arg)
    {
      free (args_info->save_arg); /* free previous argument */
      args_info->save_arg = 0;
    }
  if (args_info->save_orig)
    {
      free (args_info->save_orig); /* free previous argument */
      args_info->save_orig = 0;
    }
  if (args_info->run_time_orig)
    {
      free (args_info->run_time_orig); /* free previous argument */
      args_info->run_time_orig = 0;
    }
  if (args_info->run_time_file_name_arg)
    {
      free (args_info->run_time_file_name_arg); /* free previous argument */
      args_info->run_time_file_name_arg = 0;
    }
  if (args_info->run_time_file_name_orig)
    {
      free (args_info->run_time_file_name_orig); /* free previous argument */
      args_info->run_time_file_name_orig = 0;
    }
  if (args_info->statistics_orig)
    {
      free (args_info->statistics_orig); /* free previous argument */
      args_info->statistics_orig = 0;
    }
  if (args_info->false_negative_filename_arg)
    {
      free (args_info->false_negative_filename_arg); /* free previous argument */
      args_info->false_negative_filename_arg = 0;
    }
  if (args_info->false_negative_filename_orig)
    {
      free (args_info->false_negative_filename_orig); /* free previous argument */
      args_info->false_negative_filename_orig = 0;
    }
  if (args_info->iterations_filename_arg)
    {
      free (args_info->iterations_filename_arg); /* free previous argument */
      args_info->iterations_filename_arg = 0;
    }
  if (args_info->iterations_filename_orig)
    {
      free (args_info->iterations_filename_orig); /* free previous argument */
      args_info->iterations_filename_orig = 0;
    }
  if (args_info->expected_detections_image_arg)
    {
      free (args_info->expected_detections_image_arg); /* free previous argument */
      args_info->expected_detections_image_arg = 0;
    }
  if (args_info->expected_detections_image_orig)
    {
      free (args_info->expected_detections_image_orig); /* free previous argument */
      args_info->expected_detections_image_orig = 0;
    }
  if (args_info->detections_it_orig)
    {
      free (args_info->detections_it_orig); /* free previous argument */
      args_info->detections_it_orig = 0;
    }
  if (args_info->detections_rate_filename_arg)
    {
      free (args_info->detections_rate_filename_arg); /* free previous argument */
      args_info->detections_rate_filename_arg = 0;
    }
  if (args_info->detections_rate_filename_orig)
    {
      free (args_info->detections_rate_filename_orig); /* free previous argument */
      args_info->detections_rate_filename_orig = 0;
    }
  if (args_info->false_detections_rate_filename_arg)
    {
      free (args_info->false_detections_rate_filename_arg); /* free previous argument */
      args_info->false_detections_rate_filename_arg = 0;
    }
  if (args_info->false_detections_rate_filename_orig)
    {
      free (args_info->false_detections_rate_filename_orig); /* free previous argument */
      args_info->false_detections_rate_filename_orig = 0;
    }
  if (args_info->false_detections_rate_in_image_filename_arg)
    {
      free (args_info->false_detections_rate_in_image_filename_arg); /* free previous argument */
      args_info->false_detections_rate_in_image_filename_arg = 0;
    }
  if (args_info->false_detections_rate_in_image_filename_orig)
    {
      free (args_info->false_detections_rate_in_image_filename_orig); /* free previous argument */
      args_info->false_detections_rate_in_image_filename_orig = 0;
    }
  if (args_info->LU_min_num_of_LU_pixels_orig)
    {
      free (args_info->LU_min_num_of_LU_pixels_orig); /* free previous argument */
      args_info->LU_min_num_of_LU_pixels_orig = 0;
    }
  if (args_info->LU_gt_neighbor_orig)
    {
      free (args_info->LU_gt_neighbor_orig); /* free previous argument */
      args_info->LU_gt_neighbor_orig = 0;
    }
  if (args_info->LU_fn_orig)
    {
      free (args_info->LU_fn_orig); /* free previous argument */
      args_info->LU_fn_orig = 0;
    }
  if (args_info->LU_outliers_orig)
    {
      free (args_info->LU_outliers_orig); /* free previous argument */
      args_info->LU_outliers_orig = 0;
    }
  
  for (i = 0; i < args_info->inputs_num; ++i)
    free (args_info->inputs [i]);
  
  if (args_info->inputs_num)
    free (args_info->inputs);
  
  clear_given (args_info);
}

int
cmdline_parser_file_save(const char *filename, struct gengetopt_args_info *args_info)
{
  FILE *outfile;
  int i = 0;

  outfile = fopen(filename, "w");

  if (!outfile)
    {
      fprintf (stderr, "%s: cannot open file for writing: %s\n", CMDLINE_PARSER_PACKAGE, filename);
      return EXIT_FAILURE;
    }

  if (args_info->help_given) {
    fprintf(outfile, "%s\n", "help");
  }
  if (args_info->full_help_given) {
    fprintf(outfile, "%s\n", "full-help");
  }
  if (args_info->version_given) {
    fprintf(outfile, "%s\n", "version");
  }
  if (args_info->pattern_given) {
    if (args_info->pattern_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "pattern", args_info->pattern_orig);
    } else {
      fprintf(outfile, "%s\n", "pattern");
    }
  }
  if (args_info->mask_given) {
    if (args_info->mask_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "mask", args_info->mask_orig);
    } else {
      fprintf(outfile, "%s\n", "mask");
    }
  }
  if (args_info->images_given) {
    if (args_info->images_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "images", args_info->images_orig);
    } else {
      fprintf(outfile, "%s\n", "images");
    }
  }
  if (args_info->print_found_windows_given) {
    fprintf(outfile, "%s\n", "print-found-windows");
  }
  if (args_info->no_show_given) {
    fprintf(outfile, "%s\n", "no-show");
  }
  if (args_info->dist_given) {
    if (args_info->dist_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "dist", args_info->dist_orig);
    } else {
      fprintf(outfile, "%s\n", "dist");
    }
  }
  if (args_info->thresh_given) {
    if (args_info->thresh_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "thresh", args_info->thresh_orig);
    } else {
      fprintf(outfile, "%s\n", "thresh");
    }
  }
  if (args_info->outliers_given) {
    if (args_info->outliers_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "outliers", args_info->outliers_orig);
    } else {
      fprintf(outfile, "%s\n", "outliers");
    }
  }
  if (args_info->match_given) {
    if (args_info->match_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "match", args_info->match_orig);
    } else {
      fprintf(outfile, "%s\n", "match");
    }
  }
  if (args_info->fn_given) {
    if (args_info->fn_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "fn", args_info->fn_orig);
    } else {
      fprintf(outfile, "%s\n", "fn");
    }
  }
  if (args_info->gt_neighbor_given) {
    if (args_info->gt_neighbor_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "gt-neighbor", args_info->gt_neighbor_orig);
    } else {
      fprintf(outfile, "%s\n", "gt-neighbor");
    }
  }
  if (args_info->max_neighbor_given) {
    if (args_info->max_neighbor_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "max-neighbor", args_info->max_neighbor_orig);
    } else {
      fprintf(outfile, "%s\n", "max-neighbor");
    }
  }
  if (args_info->min_neighbor_given) {
    if (args_info->min_neighbor_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "min-neighbor", args_info->min_neighbor_orig);
    } else {
      fprintf(outfile, "%s\n", "min-neighbor");
    }
  }
  if (args_info->window_size_given) {
    if (args_info->window_size_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "window-size", args_info->window_size_orig);
    } else {
      fprintf(outfile, "%s\n", "window-size");
    }
  }
  if (args_info->max_from_window_given) {
    if (args_info->max_from_window_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "max-from-window", args_info->max_from_window_orig);
    } else {
      fprintf(outfile, "%s\n", "max-from-window");
    }
  }
  if (args_info->find_given) {
    if (args_info->find_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "find", args_info->find_orig);
    } else {
      fprintf(outfile, "%s\n", "find");
    }
  }
  if (args_info->show_dilate_border_given) {
    if (args_info->show_dilate_border_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "show-dilate-border", args_info->show_dilate_border_orig);
    } else {
      fprintf(outfile, "%s\n", "show-dilate-border");
    }
  }
  if (args_info->save_given) {
    if (args_info->save_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "save", args_info->save_orig);
    } else {
      fprintf(outfile, "%s\n", "save");
    }
  }
  if (args_info->run_time_given) {
    if (args_info->run_time_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "run-time", args_info->run_time_orig);
    } else {
      fprintf(outfile, "%s\n", "run-time");
    }
  }
  if (args_info->run_time_file_name_given) {
    if (args_info->run_time_file_name_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "run-time-file-name", args_info->run_time_file_name_orig);
    } else {
      fprintf(outfile, "%s\n", "run-time-file-name");
    }
  }
  if (args_info->statistics_given) {
    if (args_info->statistics_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "statistics", args_info->statistics_orig);
    } else {
      fprintf(outfile, "%s\n", "statistics");
    }
  }
  if (args_info->false_negative_filename_given) {
    if (args_info->false_negative_filename_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "false-negative-filename", args_info->false_negative_filename_orig);
    } else {
      fprintf(outfile, "%s\n", "false-negative-filename");
    }
  }
  if (args_info->iterations_filename_given) {
    if (args_info->iterations_filename_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "iterations-filename", args_info->iterations_filename_orig);
    } else {
      fprintf(outfile, "%s\n", "iterations-filename");
    }
  }
  if (args_info->expected_detections_image_given) {
    if (args_info->expected_detections_image_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "expected-detections-image", args_info->expected_detections_image_orig);
    } else {
      fprintf(outfile, "%s\n", "expected-detections-image");
    }
  }
  if (args_info->detections_it_given) {
    if (args_info->detections_it_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "detections-it", args_info->detections_it_orig);
    } else {
      fprintf(outfile, "%s\n", "detections-it");
    }
  }
  if (args_info->detections_rate_filename_given) {
    if (args_info->detections_rate_filename_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "detections-rate-filename", args_info->detections_rate_filename_orig);
    } else {
      fprintf(outfile, "%s\n", "detections-rate-filename");
    }
  }
  if (args_info->false_detections_rate_filename_given) {
    if (args_info->false_detections_rate_filename_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "false-detections-rate-filename", args_info->false_detections_rate_filename_orig);
    } else {
      fprintf(outfile, "%s\n", "false-detections-rate-filename");
    }
  }
  if (args_info->false_detections_rate_in_image_filename_given) {
    if (args_info->false_detections_rate_in_image_filename_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "false-detections-rate-in-image-filename", args_info->false_detections_rate_in_image_filename_orig);
    } else {
      fprintf(outfile, "%s\n", "false-detections-rate-in-image-filename");
    }
  }
  if (args_info->LU_off_given) {
    fprintf(outfile, "%s\n", "LU-off");
  }
  if (args_info->LU_min_num_of_LU_pixels_given) {
    if (args_info->LU_min_num_of_LU_pixels_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "LU-min-num-of-LU-pixels", args_info->LU_min_num_of_LU_pixels_orig);
    } else {
      fprintf(outfile, "%s\n", "LU-min-num-of-LU-pixels");
    }
  }
  if (args_info->LU_gt_neighbor_given) {
    if (args_info->LU_gt_neighbor_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "LU-gt-neighbor", args_info->LU_gt_neighbor_orig);
    } else {
      fprintf(outfile, "%s\n", "LU-gt-neighbor");
    }
  }
  if (args_info->LU_fn_given) {
    if (args_info->LU_fn_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "LU-fn", args_info->LU_fn_orig);
    } else {
      fprintf(outfile, "%s\n", "LU-fn");
    }
  }
  if (args_info->LU_outliers_given) {
    if (args_info->LU_outliers_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "LU-outliers", args_info->LU_outliers_orig);
    } else {
      fprintf(outfile, "%s\n", "LU-outliers");
    }
  }
  
  fclose (outfile);

  i = EXIT_SUCCESS;
  return i;
}

void
cmdline_parser_free (struct gengetopt_args_info *args_info)
{
  cmdline_parser_release (args_info);
}


/* gengetopt_strdup() */
/* strdup.c replacement of strdup, which is not standard */
char *
gengetopt_strdup (const char *s)
{
  char *result = NULL;
  if (!s)
    return result;

  result = (char*)malloc(strlen(s) + 1);
  if (result == (char*)0)
    return (char*)0;
  strcpy(result, s);
  return result;
}

int
cmdline_parser (int argc, char * const *argv, struct gengetopt_args_info *args_info)
{
  return cmdline_parser2 (argc, argv, args_info, 0, 1, 1);
}

int
cmdline_parser2 (int argc, char * const *argv, struct gengetopt_args_info *args_info, int override, int initialize, int check_required)
{
  int result;

  result = cmdline_parser_internal (argc, argv, args_info, override, initialize, check_required, NULL);

  if (result == EXIT_FAILURE)
    {
      cmdline_parser_free (args_info);
      exit (EXIT_FAILURE);
    }
  
  return result;
}

int
cmdline_parser_required (struct gengetopt_args_info *args_info, const char *prog_name)
{
  int result = EXIT_SUCCESS;

  if (cmdline_parser_required2(args_info, prog_name, NULL) > 0)
    result = EXIT_FAILURE;

  if (result == EXIT_FAILURE)
    {
      cmdline_parser_free (args_info);
      exit (EXIT_FAILURE);
    }
  
  return result;
}

int
cmdline_parser_required2 (struct gengetopt_args_info *args_info, const char *prog_name, const char *additional_error)
{
  int error = 0;

  /* checks for required options */
  if (! args_info->pattern_given)
    {
      fprintf (stderr, "%s: '--pattern' ('-P') option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error = 1;
    }
  
  if (! args_info->images_given)
    {
      fprintf (stderr, "%s: '--images' ('-I') option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error = 1;
    }
  
  
  /* checks for dependences among options */

  return error;
}

int
cmdline_parser_internal (int argc, char * const *argv, struct gengetopt_args_info *args_info, int override, int initialize, int check_required, const char *additional_error)
{
  int c;	/* Character of the parsed option.  */

  int error = 0;
  struct gengetopt_args_info local_args_info;

  if (initialize)
    cmdline_parser_init (args_info);

  cmdline_parser_init (&local_args_info);

  optarg = 0;
  optind = 0;
  opterr = 1;
  optopt = '?';

  while (1)
    {
      int option_index = 0;
      char *stop_char;

      static struct option long_options[] = {
        { "help",	0, NULL, 'h' },
        { "full-help",	0, NULL, 0 },
        { "version",	0, NULL, 'V' },
        { "pattern",	1, NULL, 'P' },
        { "mask",	1, NULL, 'M' },
        { "images",	1, NULL, 'I' },
        { "print-found-windows",	0, NULL, 0 },
        { "no-show",	0, NULL, 0 },
        { "dist",	1, NULL, 'D' },
        { "thresh",	1, NULL, 'T' },
        { "outliers",	1, NULL, 0 },
        { "match",	1, NULL, 0 },
        { "fn",	1, NULL, 0 },
        { "gt-neighbor",	1, NULL, 0 },
        { "max-neighbor",	1, NULL, 0 },
        { "min-neighbor",	1, NULL, 0 },
        { "window-size",	1, NULL, 0 },
        { "max-from-window",	1, NULL, 0 },
        { "find",	1, NULL, 0 },
        { "show-dilate-border",	1, NULL, 0 },
        { "save",	1, NULL, 0 },
        { "run-time",	1, NULL, 0 },
        { "run-time-file-name",	1, NULL, 0 },
        { "statistics",	1, NULL, 0 },
        { "false-negative-filename",	1, NULL, 0 },
        { "iterations-filename",	1, NULL, 0 },
        { "expected-detections-image",	1, NULL, 0 },
        { "detections-it",	1, NULL, 0 },
        { "detections-rate-filename",	1, NULL, 0 },
        { "false-detections-rate-filename",	1, NULL, 0 },
        { "false-detections-rate-in-image-filename",	1, NULL, 0 },
        { "LU-off",	0, NULL, 0 },
        { "LU-min-num-of-LU-pixels",	1, NULL, 0 },
        { "LU-gt-neighbor",	1, NULL, 0 },
        { "LU-fn",	1, NULL, 0 },
        { "LU-outliers",	1, NULL, 0 },
        { NULL,	0, NULL, 0 }
      };

      stop_char = 0;
      c = getopt_long (argc, argv, "hVP:M:I:D:T:", long_options, &option_index);

      if (c == -1) break;	/* Exit from `while (1)' loop.  */

      switch (c)
        {
        case 'h':	/* Print help and exit.  */
          cmdline_parser_print_help ();
          cmdline_parser_free (&local_args_info);
          exit (EXIT_SUCCESS);

        case 'V':	/* Print version and exit.  */
          cmdline_parser_print_version ();
          cmdline_parser_free (&local_args_info);
          exit (EXIT_SUCCESS);

        case 'P':	/* The file name of the pattern image..  */
          if (local_args_info.pattern_given)
            {
              fprintf (stderr, "%s: `--pattern' (`-P') option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
              goto failure;
            }
          if (args_info->pattern_given && ! override)
            continue;
          local_args_info.pattern_given = 1;
          args_info->pattern_given = 1;
          if (args_info->pattern_arg)
            free (args_info->pattern_arg); /* free previous string */
          args_info->pattern_arg = gengetopt_strdup (optarg);
          if (args_info->pattern_orig)
            free (args_info->pattern_orig); /* free previous string */
          args_info->pattern_orig = gengetopt_strdup (optarg);
          break;

        case 'M':	/* The file name of the pattern mask image (0<->not in mask, other values<->in mask). If not given all pixels are considered..  */
          if (local_args_info.mask_given)
            {
              fprintf (stderr, "%s: `--mask' (`-M') option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
              goto failure;
            }
          if (args_info->mask_given && ! override)
            continue;
          local_args_info.mask_given = 1;
          args_info->mask_given = 1;
          if (args_info->mask_arg)
            free (args_info->mask_arg); /* free previous string */
          args_info->mask_arg = gengetopt_strdup (optarg);
          if (args_info->mask_orig)
            free (args_info->mask_orig); /* free previous string */
          args_info->mask_orig = gengetopt_strdup (optarg);
          break;

        case 'I':	/* The file name of the image, or, (if ends with '/') the name of the directory containing the images..  */
          if (local_args_info.images_given)
            {
              fprintf (stderr, "%s: `--images' (`-I') option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
              goto failure;
            }
          if (args_info->images_given && ! override)
            continue;
          local_args_info.images_given = 1;
          args_info->images_given = 1;
          if (args_info->images_arg)
            free (args_info->images_arg); /* free previous string */
          args_info->images_arg = gengetopt_strdup (optarg);
          if (args_info->images_orig)
            free (args_info->images_orig); /* free previous string */
          args_info->images_orig = gengetopt_strdup (optarg);
          break;

        case 'D':	/* Type of distance (possible values: abs,gt-pairs). abs: ''Thresholded Absolute Difference'' from the paper. gt-pairs: ''Monotonic Relations'' from the paper..  */
          if (local_args_info.dist_given)
            {
              fprintf (stderr, "%s: `--dist' (`-D') option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
              goto failure;
            }
          if (args_info->dist_given && ! override)
            continue;
          local_args_info.dist_given = 1;
          args_info->dist_given = 1;
          if (args_info->dist_arg)
            free (args_info->dist_arg); /* free previous string */
          args_info->dist_arg = gengetopt_strdup (optarg);
          if (args_info->dist_orig)
            free (args_info->dist_orig); /* free previous string */
          args_info->dist_orig = gengetopt_strdup (optarg);
          break;

        case 'T':	/* Threshold for distance. 0 <= thresh <=50. Defaults: gt-pairs = 0, abs = 20..  */
          if (local_args_info.thresh_given)
            {
              fprintf (stderr, "%s: `--thresh' (`-T') option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
              goto failure;
            }
          if (args_info->thresh_given && ! override)
            continue;
          local_args_info.thresh_given = 1;
          args_info->thresh_given = 1;
          args_info->thresh_arg = strtol (optarg, &stop_char, 0);
          if (!(stop_char && *stop_char == '\0')) {
            fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
            goto failure;
          }
          if (args_info->thresh_orig)
            free (args_info->thresh_orig); /* free previous string */
          args_info->thresh_orig = gengetopt_strdup (optarg);
          break;


        case 0:	/* Long option with no short option */
          if (strcmp (long_options[option_index].name, "full-help") == 0) {
            cmdline_parser_print_full_help ();
            cmdline_parser_free (&local_args_info);
            exit (EXIT_SUCCESS);}
          

          /* The program will print to the standard output the top left of the masked windows where the pattern was found and the distance of each masked window to the pattern. The format of the output is: y x distance. x and y starts from 0..  */
          if (strcmp (long_options[option_index].name, "print-found-windows") == 0)
          {
            if (local_args_info.print_found_windows_given)
              {
                fprintf (stderr, "%s: `--print-found-windows' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->print_found_windows_given && ! override)
              continue;
            local_args_info.print_found_windows_given = 1;
            args_info->print_found_windows_given = 1;
            args_info->print_found_windows_flag = !(args_info->print_found_windows_flag);
          }
          /* The program will not show the places where the pattern was found..  */
          else if (strcmp (long_options[option_index].name, "no-show") == 0)
          {
            if (local_args_info.no_show_given)
              {
                fprintf (stderr, "%s: `--no-show' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->no_show_given && ! override)
              continue;
            local_args_info.no_show_given = 1;
            args_info->no_show_given = 1;
            args_info->no_show_flag = !(args_info->no_show_flag);
          }
          /* Maximum percent of outliers allowed. i.e: Similar windows are if the Hamming distance is smaller or equal to (outliers/100)*num_of_features. Defaults: gt-pairs = 25, abs = 40..  */
          else if (strcmp (long_options[option_index].name, "outliers") == 0)
          {
            if (local_args_info.outliers_given)
              {
                fprintf (stderr, "%s: `--outliers' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->outliers_given && ! override)
              continue;
            local_args_info.outliers_given = 1;
            args_info->outliers_given = 1;
            args_info->outliers_arg = strtod (optarg, &stop_char);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->outliers_orig)
              free (args_info->outliers_orig); /* free previous string */
            args_info->outliers_orig = gengetopt_strdup (optarg);
          }
          /* Matching algorithm (possible values: exact, seq). seq is the P-SPRT sequential procedure from the paper..  */
          else if (strcmp (long_options[option_index].name, "match") == 0)
          {
            if (local_args_info.match_given)
              {
                fprintf (stderr, "%s: `--match' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->match_given && ! override)
              continue;
            local_args_info.match_given = 1;
            args_info->match_given = 1;
            if (args_info->match_arg)
              free (args_info->match_arg); /* free previous string */
            args_info->match_arg = gengetopt_strdup (optarg);
            if (args_info->match_orig)
              free (args_info->match_orig); /* free previous string */
            args_info->match_orig = gengetopt_strdup (optarg);
          }
          /* Bound on false negative error rate, only needed when matching is with sampling (match=seq)..  */
          else if (strcmp (long_options[option_index].name, "fn") == 0)
          {
            if (local_args_info.fn_given)
              {
                fprintf (stderr, "%s: `--fn' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->fn_given && ! override)
              continue;
            local_args_info.fn_given = 1;
            args_info->fn_given = 1;
            args_info->fn_arg = strtod (optarg, &stop_char);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->fn_orig)
              free (args_info->fn_orig); /* free previous string */
            args_info->fn_orig = gengetopt_strdup (optarg);
          }
          /* A pixel (x',y') is greater than it's neighbor (x,y) when: g(x,y) > g(x',y')+gt-neighbor. thresh should be <= than gt-neighbor..  */
          else if (strcmp (long_options[option_index].name, "gt-neighbor") == 0)
          {
            if (local_args_info.gt_neighbor_given)
              {
                fprintf (stderr, "%s: `--gt-neighbor' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->gt_neighbor_given && ! override)
              continue;
            local_args_info.gt_neighbor_given = 1;
            args_info->gt_neighbor_given = 1;
            args_info->gt_neighbor_arg = strtol (optarg, &stop_char, 0);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->gt_neighbor_orig)
              free (args_info->gt_neighbor_orig); /* free previous string */
            args_info->gt_neighbor_orig = gengetopt_strdup (optarg);
          }
          /* Maximum distance of a neighbor. i.e: (x,y) is a neighbor of (x',y') when the Euclidean distance between them is less than or equal to max-neighbor-val..  */
          else if (strcmp (long_options[option_index].name, "max-neighbor") == 0)
          {
            if (local_args_info.max_neighbor_given)
              {
                fprintf (stderr, "%s: `--max-neighbor' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->max_neighbor_given && ! override)
              continue;
            local_args_info.max_neighbor_given = 1;
            args_info->max_neighbor_given = 1;
            args_info->max_neighbor_arg = strtol (optarg, &stop_char, 0);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->max_neighbor_orig)
              free (args_info->max_neighbor_orig); /* free previous string */
            args_info->max_neighbor_orig = gengetopt_strdup (optarg);
          }
          /* Minimum distance of a neighbor. i.e: (x,y) is a neighbor of (x',y') if if the Euclidean distance between them is greater than or equal to max-neighbor-val..  */
          else if (strcmp (long_options[option_index].name, "min-neighbor") == 0)
          {
            if (local_args_info.min_neighbor_given)
              {
                fprintf (stderr, "%s: `--min-neighbor' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->min_neighbor_given && ! override)
              continue;
            local_args_info.min_neighbor_given = 1;
            args_info->min_neighbor_given = 1;
            args_info->min_neighbor_arg = strtol (optarg, &stop_char, 0);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->min_neighbor_orig)
              free (args_info->min_neighbor_orig); /* free previous string */
            args_info->min_neighbor_orig = gengetopt_strdup (optarg);
          }
          /* The pattern is divided into windows of window-size..  */
          else if (strcmp (long_options[option_index].name, "window-size") == 0)
          {
            if (local_args_info.window_size_given)
              {
                fprintf (stderr, "%s: `--window-size' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->window_size_given && ! override)
              continue;
            local_args_info.window_size_given = 1;
            args_info->window_size_given = 1;
            args_info->window_size_arg = strtol (optarg, &stop_char, 0);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->window_size_orig)
              free (args_info->window_size_orig); /* free previous string */
            args_info->window_size_orig = gengetopt_strdup (optarg);
          }
          /* From each window a maximum of max-from-window pixels pairs is taken. If not given it's the maximum number of pixels pairs possible..  */
          else if (strcmp (long_options[option_index].name, "max-from-window") == 0)
          {
            if (local_args_info.max_from_window_given)
              {
                fprintf (stderr, "%s: `--max-from-window' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->max_from_window_given && ! override)
              continue;
            local_args_info.max_from_window_given = 1;
            args_info->max_from_window_given = 1;
            args_info->max_from_window_arg = strtol (optarg, &stop_char, 0);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->max_from_window_orig)
              free (args_info->max_from_window_orig); /* free previous string */
            args_info->max_from_window_orig = gengetopt_strdup (optarg);
          }
          /* Type of find (possible values: min, lessOutliers). min: finds only the windows with the minimum distance. lessOutliers: finds all windows that have a distance which is smaller or equal to (outliers/100)*num_of_features.  */
          else if (strcmp (long_options[option_index].name, "find") == 0)
          {
            if (local_args_info.find_given)
              {
                fprintf (stderr, "%s: `--find' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->find_given && ! override)
              continue;
            local_args_info.find_given = 1;
            args_info->find_given = 1;
            if (args_info->find_arg)
              free (args_info->find_arg); /* free previous string */
            args_info->find_arg = gengetopt_strdup (optarg);
            if (args_info->find_orig)
              free (args_info->find_orig); /* free previous string */
            args_info->find_orig = gengetopt_strdup (optarg);
          }
          /* The size of dilation of the border of the mask that will be shown will be 2*val-1. Should be => 1.  */
          else if (strcmp (long_options[option_index].name, "show-dilate-border") == 0)
          {
            if (local_args_info.show_dilate_border_given)
              {
                fprintf (stderr, "%s: `--show-dilate-border' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->show_dilate_border_given && ! override)
              continue;
            local_args_info.show_dilate_border_given = 1;
            args_info->show_dilate_border_given = 1;
            args_info->show_dilate_border_arg = strtol (optarg, &stop_char, 0);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->show_dilate_border_orig)
              free (args_info->show_dilate_border_orig); /* free previous string */
            args_info->show_dilate_border_orig = gengetopt_strdup (optarg);
          }
          /* If given results will be saved in the given directory..  */
          else if (strcmp (long_options[option_index].name, "save") == 0)
          {
            if (local_args_info.save_given)
              {
                fprintf (stderr, "%s: `--save' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->save_given && ! override)
              continue;
            local_args_info.save_given = 1;
            args_info->save_given = 1;
            if (args_info->save_arg)
              free (args_info->save_arg); /* free previous string */
            args_info->save_arg = gengetopt_strdup (optarg);
            if (args_info->save_orig)
              free (args_info->save_orig); /* free previous string */
            args_info->save_orig = gengetopt_strdup (optarg);
          }
          /* Number of iterations that the program will do in order to measure running time. Note that if it's <=0 no run time information will be displayed..  */
          else if (strcmp (long_options[option_index].name, "run-time") == 0)
          {
            if (local_args_info.run_time_given)
              {
                fprintf (stderr, "%s: `--run-time' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->run_time_given && ! override)
              continue;
            local_args_info.run_time_given = 1;
            args_info->run_time_given = 1;
            args_info->run_time_arg = strtol (optarg, &stop_char, 0);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->run_time_orig)
              free (args_info->run_time_orig); /* free previous string */
            args_info->run_time_orig = gengetopt_strdup (optarg);
          }
          /* The file name that the run time (in seconds) will be written to. If not given it's written only to stdout..  */
          else if (strcmp (long_options[option_index].name, "run-time-file-name") == 0)
          {
            if (local_args_info.run_time_file_name_given)
              {
                fprintf (stderr, "%s: `--run-time-file-name' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->run_time_file_name_given && ! override)
              continue;
            local_args_info.run_time_file_name_given = 1;
            args_info->run_time_file_name_given = 1;
            if (args_info->run_time_file_name_arg)
              free (args_info->run_time_file_name_arg); /* free previous string */
            args_info->run_time_file_name_arg = gengetopt_strdup (optarg);
            if (args_info->run_time_file_name_orig)
              free (args_info->run_time_file_name_orig); /* free previous string */
            args_info->run_time_file_name_orig = gengetopt_strdup (optarg);
          }
          /* Number of iterations that the program will do in order to check the statistics - average false negative and average iterations. Note that if it's <=0 no statistics will be displayed. Should not be given with exact..  */
          else if (strcmp (long_options[option_index].name, "statistics") == 0)
          {
            if (local_args_info.statistics_given)
              {
                fprintf (stderr, "%s: `--statistics' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->statistics_given && ! override)
              continue;
            local_args_info.statistics_given = 1;
            args_info->statistics_given = 1;
            args_info->statistics_arg = strtol (optarg, &stop_char, 0);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->statistics_orig)
              free (args_info->statistics_orig); /* free previous string */
            args_info->statistics_orig = gengetopt_strdup (optarg);
          }
          /* The file name that the false negative error rate (windows that are similar i.e: are smaller than the (outliers/100)*pattern_size, that were classified as not similar) will be written to. If not given it's written only to stdout..  */
          else if (strcmp (long_options[option_index].name, "false-negative-filename") == 0)
          {
            if (local_args_info.false_negative_filename_given)
              {
                fprintf (stderr, "%s: `--false-negative-filename' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->false_negative_filename_given && ! override)
              continue;
            local_args_info.false_negative_filename_given = 1;
            args_info->false_negative_filename_given = 1;
            if (args_info->false_negative_filename_arg)
              free (args_info->false_negative_filename_arg); /* free previous string */
            args_info->false_negative_filename_arg = gengetopt_strdup (optarg);
            if (args_info->false_negative_filename_orig)
              free (args_info->false_negative_filename_orig); /* free previous string */
            args_info->false_negative_filename_orig = gengetopt_strdup (optarg);
          }
          /* The file name that the average iterations per window will be written to. If not given it's written only to stdout..  */
          else if (strcmp (long_options[option_index].name, "iterations-filename") == 0)
          {
            if (local_args_info.iterations_filename_given)
              {
                fprintf (stderr, "%s: `--iterations-filename' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->iterations_filename_given && ! override)
              continue;
            local_args_info.iterations_filename_given = 1;
            args_info->iterations_filename_given = 1;
            if (args_info->iterations_filename_arg)
              free (args_info->iterations_filename_arg); /* free previous string */
            args_info->iterations_filename_arg = gengetopt_strdup (optarg);
            if (args_info->iterations_filename_orig)
              free (args_info->iterations_filename_orig); /* free previous string */
            args_info->iterations_filename_orig = gengetopt_strdup (optarg);
          }
          /* The file name of the expected detections image. Same size as the given image (-I option). The values in this map are: EXPECTED_DETECT= 255; NOT_EXPECTED_DETECT= 0; DOES_NOT_MATTER_EXPECTED_DETECT= 100.  */
          else if (strcmp (long_options[option_index].name, "expected-detections-image") == 0)
          {
            if (local_args_info.expected_detections_image_given)
              {
                fprintf (stderr, "%s: `--expected-detections-image' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->expected_detections_image_given && ! override)
              continue;
            local_args_info.expected_detections_image_given = 1;
            args_info->expected_detections_image_given = 1;
            if (args_info->expected_detections_image_arg)
              free (args_info->expected_detections_image_arg); /* free previous string */
            args_info->expected_detections_image_arg = gengetopt_strdup (optarg);
            if (args_info->expected_detections_image_orig)
              free (args_info->expected_detections_image_orig); /* free previous string */
            args_info->expected_detections_image_orig = gengetopt_strdup (optarg);
          }
          /* Number of iterations that the program will do in order to measure detection and running time. Note that if it's <=0 no detections and false detections information will be displayed..  */
          else if (strcmp (long_options[option_index].name, "detections-it") == 0)
          {
            if (local_args_info.detections_it_given)
              {
                fprintf (stderr, "%s: `--detections-it' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->detections_it_given && ! override)
              continue;
            local_args_info.detections_it_given = 1;
            args_info->detections_it_given = 1;
            args_info->detections_it_arg = strtol (optarg, &stop_char, 0);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->detections_it_orig)
              free (args_info->detections_it_orig); /* free previous string */
            args_info->detections_it_orig = gengetopt_strdup (optarg);
          }
          /* The file name that the average detection rate (percent of images that at least one of the expected was found, out of all iterations on images that contains expected) will be written to. If not given it's written only to stdout..  */
          else if (strcmp (long_options[option_index].name, "detections-rate-filename") == 0)
          {
            if (local_args_info.detections_rate_filename_given)
              {
                fprintf (stderr, "%s: `--detections-rate-filename' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->detections_rate_filename_given && ! override)
              continue;
            local_args_info.detections_rate_filename_given = 1;
            args_info->detections_rate_filename_given = 1;
            if (args_info->detections_rate_filename_arg)
              free (args_info->detections_rate_filename_arg); /* free previous string */
            args_info->detections_rate_filename_arg = gengetopt_strdup (optarg);
            if (args_info->detections_rate_filename_orig)
              free (args_info->detections_rate_filename_orig); /* free previous string */
            args_info->detections_rate_filename_orig = gengetopt_strdup (optarg);
          }
          /* The file name that the average false detection rate (percent of images that at least one of the not expected was found, out of all iterations on images that contains not expected) will be written to. If not given it's written only to stdout..  */
          else if (strcmp (long_options[option_index].name, "false-detections-rate-filename") == 0)
          {
            if (local_args_info.false_detections_rate_filename_given)
              {
                fprintf (stderr, "%s: `--false-detections-rate-filename' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->false_detections_rate_filename_given && ! override)
              continue;
            local_args_info.false_detections_rate_filename_given = 1;
            args_info->false_detections_rate_filename_given = 1;
            if (args_info->false_detections_rate_filename_arg)
              free (args_info->false_detections_rate_filename_arg); /* free previous string */
            args_info->false_detections_rate_filename_arg = gengetopt_strdup (optarg);
            if (args_info->false_detections_rate_filename_orig)
              free (args_info->false_detections_rate_filename_orig); /* free previous string */
            args_info->false_detections_rate_filename_orig = gengetopt_strdup (optarg);
          }
          /* The file name that the average false detection rate (percent of places that were found and were not expect to be found, out of all not expected places) will be written to. If not given it's written only to stdout..  */
          else if (strcmp (long_options[option_index].name, "false-detections-rate-in-image-filename") == 0)
          {
            if (local_args_info.false_detections_rate_in_image_filename_given)
              {
                fprintf (stderr, "%s: `--false-detections-rate-in-image-filename' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->false_detections_rate_in_image_filename_given && ! override)
              continue;
            local_args_info.false_detections_rate_in_image_filename_given = 1;
            args_info->false_detections_rate_in_image_filename_given = 1;
            if (args_info->false_detections_rate_in_image_filename_arg)
              free (args_info->false_detections_rate_in_image_filename_arg); /* free previous string */
            args_info->false_detections_rate_in_image_filename_arg = gengetopt_strdup (optarg);
            if (args_info->false_detections_rate_in_image_filename_orig)
              free (args_info->false_detections_rate_in_image_filename_orig); /* free previous string */
            args_info->false_detections_rate_in_image_filename_orig = gengetopt_strdup (optarg);
          }
          /* The program will not use the LU jump technique (will be more accurate but slower)..  */
          else if (strcmp (long_options[option_index].name, "LU-off") == 0)
          {
            if (local_args_info.LU_off_given)
              {
                fprintf (stderr, "%s: `--LU-off' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->LU_off_given && ! override)
              continue;
            local_args_info.LU_off_given = 1;
            args_info->LU_off_given = 1;
            args_info->LU_off_flag = !(args_info->LU_off_flag);
          }
          /* Minimum number of LU pixels in the LU mask.  */
          else if (strcmp (long_options[option_index].name, "LU-min-num-of-LU-pixels") == 0)
          {
            if (local_args_info.LU_min_num_of_LU_pixels_given)
              {
                fprintf (stderr, "%s: `--LU-min-num-of-LU-pixels' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->LU_min_num_of_LU_pixels_given && ! override)
              continue;
            local_args_info.LU_min_num_of_LU_pixels_given = 1;
            args_info->LU_min_num_of_LU_pixels_given = 1;
            args_info->LU_min_num_of_LU_pixels_arg = strtol (optarg, &stop_char, 0);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->LU_min_num_of_LU_pixels_orig)
              free (args_info->LU_min_num_of_LU_pixels_orig); /* free previous string */
            args_info->LU_min_num_of_LU_pixels_orig = gengetopt_strdup (optarg);
          }
          /* Same as gt-neighbor for finding LU rank of pairs. default: abs=5 gt-pairs=20.  */
          else if (strcmp (long_options[option_index].name, "LU-gt-neighbor") == 0)
          {
            if (local_args_info.LU_gt_neighbor_given)
              {
                fprintf (stderr, "%s: `--LU-gt-neighbor' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->LU_gt_neighbor_given && ! override)
              continue;
            local_args_info.LU_gt_neighbor_given = 1;
            args_info->LU_gt_neighbor_given = 1;
            args_info->LU_gt_neighbor_arg = strtol (optarg, &stop_char, 0);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->LU_gt_neighbor_orig)
              free (args_info->LU_gt_neighbor_orig); /* free previous string */
            args_info->LU_gt_neighbor_orig = gengetopt_strdup (optarg);
          }
          /* same as --fn for LU stage.  */
          else if (strcmp (long_options[option_index].name, "LU-fn") == 0)
          {
            if (local_args_info.LU_fn_given)
              {
                fprintf (stderr, "%s: `--LU-fn' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->LU_fn_given && ! override)
              continue;
            local_args_info.LU_fn_given = 1;
            args_info->LU_fn_given = 1;
            args_info->LU_fn_arg = strtod (optarg, &stop_char);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->LU_fn_orig)
              free (args_info->LU_fn_orig); /* free previous string */
            args_info->LU_fn_orig = gengetopt_strdup (optarg);
          }
          /* same as --outliers for LU stage. Default: equals to outliers.  */
          else if (strcmp (long_options[option_index].name, "LU-outliers") == 0)
          {
            if (local_args_info.LU_outliers_given)
              {
                fprintf (stderr, "%s: `--LU-outliers' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->LU_outliers_given && ! override)
              continue;
            local_args_info.LU_outliers_given = 1;
            args_info->LU_outliers_given = 1;
            args_info->LU_outliers_arg = strtod (optarg, &stop_char);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->LU_outliers_orig)
              free (args_info->LU_outliers_orig); /* free previous string */
            args_info->LU_outliers_orig = gengetopt_strdup (optarg);
          }
          
          break;
        case '?':	/* Invalid option.  */
          /* `getopt_long' already printed an error message.  */
          goto failure;

        default:	/* bug: option not considered.  */
          fprintf (stderr, "%s: option unknown: %c%s\n", CMDLINE_PARSER_PACKAGE, c, (additional_error ? additional_error : ""));
          abort ();
        } /* switch */
    } /* while */



  if (check_required)
    {
      error += cmdline_parser_required2 (args_info, argv[0], additional_error);
    }

  cmdline_parser_release (&local_args_info);

  if ( error )
    return (EXIT_FAILURE);

  if (optind < argc)
    {
      int i = 0 ;
      int found_prog_name = 0;
      /* whether program name, i.e., argv[0], is in the remaining args
         (this may happen with some implementations of getopt,
          but surely not with the one included by gengetopt) */

      i = optind;
      while (i < argc)
        if (argv[i++] == argv[0]) {
          found_prog_name = 1;
          break;
        }
      i = 0;

      args_info->inputs_num = argc - optind - found_prog_name;
      args_info->inputs =
        (char **)(malloc ((args_info->inputs_num)*sizeof(char *))) ;
      while (optind < argc)
        if (argv[optind++] != argv[0])
          args_info->inputs[ i++ ] = gengetopt_strdup (argv[optind-1]) ;
    }

  return 0;

failure:
  
  cmdline_parser_release (&local_args_info);
  return (EXIT_FAILURE);
}


// Copyright (c) 2012, Ofir Pele
// All rights reserved.

// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met: 
//    * Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
//    * Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//    * Neither the name of the The Hebrew University of Jerusalem nor the
//    names of its contributors may be used to endorse or promote products
//    derived from this software without specific prior written permission.

// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
// PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
